### Registers
####General purpose: 
- A, B
Initial: random

####Memory address:
May be clobbered by the system for e.g. loads

- M0, M1, M2 
Initial: random

#### Stack pointer (SYSTEM) - Read only (except via increment, decrement)
Need two stack pointers - during ISR, don't want to use stack of existing process. Suppose we change the stack pointer, we'd need to save it, which would take stack memory. K for kernel. I guess we don't need IN/OUT for these. OUT may be useful for debugging.

Made out of 4 bit up/down binary counters.
- K0, K1, K2 - initial random
####Stack pointer (USER): 
Actually made out of 4 bit up/down binary counters. Need IN to set it for context switch. Out to save for context switch.

- S0, S1, S2 - initial random

#### Status/Control SC register

Need to be able to set individiual bits somehow.
- Interrupt enable (initial 0) - jk flipflop
- Carry (initial 0) - set from ALU - d flipflop
- Zero (initial 0) - set from ALU - d flipflop

#### Interrupt register - 
Level triggered, but latched on each clock, each device will assert until ack comes and it decides to stop asserting.
Note this means devices need to assert the line until they get serviced (level triggered).
- Timer
- Software (e.g. syscall)
- Keyboard
- Mouse
- Network
- Storage?

#### Program counter
Actually made out of 4 bit binary counters.
- PC0, PC1, PC2
Initial: 0

#### SUM - read only 
Output from ALU

#### DISP - Display output - write only
- DISP

#### Internal MMU registers for loading - write only
- MMU0, MMU1, MMU2

#### Task register - rw
Stores id of current task
- TASK

#### Auxiliary register - write only
Stores 4 bits of input into EEPROM
- AUX

#### Opcode register - write only
Needs to be counter

### Not registers, but need control signals
#### MMU
Need boot eeprom mapped into memory. Memory protection. Both read and write permissions?

- MMU_IN - write into memory, checks permissions unless task id is 0?
- MMU_CONTROL_IN - write into memory protection memory
- MMU_OUT - get data from memory / eeprom / whatever

#### MLU
Ops: AND, OR, NOT, XOR, POPCOUNT, MUL, DIV, MOD - lshift and rshift implemented as MUL and DIV.

- MLU out
- 3 bits for operation select
- Wired to A, B

### Control signals
5 + 5 + 4 + 2 = 16 bits hrmmm

#### Bus related
INs: A, B, M0, M1, M2, S0, S1, S2, PC0, PC1, PC2, MMU0, MMU1, MMU2, MMU, MMU_CONTROL, DISP, TASK, OPCODE, + peripherals

OUTs: A, B, M0, M1, M2, S0, S1, S2, K0, K1, K2, INTERRUPT, SUM, MMU, TASK, MLU + peripherals
INTERRUPT register needs to be read for ISR to know which devices to talk to.

#### Output
16 line decoder may be sufficient - 4 bits:
- SUB
- PC increment
- OPCODE increment
- AUX increment
- Reset uop counter (need to be careful with clocks here?)
- RESET - also wired to reset uop counter signal 
- SP increment
- SP decrement
- KSP increment
- KSP decrement
- Set flags from ALU (zero and carry)
- Set interrupt enable
- Unset interrupt enable

Also MLU operation select:
- MLU - 3 bit operation select

^ Select between above two using 2 bits.

#### Input
- 4 lower data bus bits into binary counter then fed into EEPROM
- 4 micro-op counter bits
- 8 opcode bits
- 1 interrupt bit
- 1 page fault bit?
- 1 spare

### Instructions
0 - LOAD from bootloader? / Page fault?
LDA, LDB, LDC, LDD, OUT - immediate, memory addr, indirect memory addr
ADD, SUB, MUL, DIV, MOD - A, B
HLT, RST
JNZ, JZ, JMP
JLES, JLTS, JGES, JGTS
JLE, JLT, JGE, JGT
AND, OR, NOT, XOR - A, B
INT - software interrupt
PUSH, POP
RTI - return from interrupt - re-enables interrupts
bitwise ops (and, or, not, xor, nand?)

### Module notes:
#### MMU
Need to also interface into EEPROM for boot

#### Reset
Need to make sure everything is properly reset.

- TASK reg set to 0
- Boot EEPROM used

#### ALU
Produces carry and zero signal.

#### Clock
Pierce oscillator. Add frequency dividers using JK flipflops. 12 MHz with frequency dividers

### Peripherals

#### Keyboard
#### Mouse
#### VGA
#### Ethernet
#### USB mass storage?

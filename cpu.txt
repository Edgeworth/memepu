### Registers
####General purpose: 
C?
- A, B

####Memory address:
May be clobbered by the system for e.g. loads

- M0, M1, M2 

#### Stack pointer (SYSTEM) - Read only (except via increment, decrement)
Need two stack pointers - during ISR, don't want to use stack of existing process. Suppose we change the stack pointer, we'd need to save it, which would take stack memory. K for kernel. I guess we don't need IN/OUT for these. OUT may be useful for debugging.

Made out of 4 bit up/down binary counters.

- K0, K1, K2 

####Stack pointer (USER): 
Actually made out of 4 bit up/down binary counters. Need IN to set it for context switch. Out to save for context switch.

- S0, S1, S2

#### Status/Control SCI register
Is it really necessary to store carry bit? Can just read from ALU. Means that ADD can't modify the registers because we want to jump based on carry of some operation.

Need to be able to set individiual bits somehow.
- Interrupt enable (initial 0) 
- Carry (initial 0) - set from ALU
- Zero

#### Interrupt register - 
Level triggered, each device will assert until ack comes and it decides to stop asserting. 
- Timer
- Software (e.g. syscall)
- Keyboard
- Mouse
- Network
- Storage?

#### Program counter
Actually made out of 4 bit binary counters.
- PC0, PC1, PC2

#### SUM - read only 
Output from ALU

#### DISP - Display output - write only
- DISP

#### Internal MMU registers for loading - read only

- MMU0, MMU1, MMU2

#### Task register - rw
Stores id of current task

- TASK

#### Control register - write only
Stores 8 bits of input into EEPROM

- CTRL

#### Opcode register - write only
Needs to be counter

### Not registers, but need control signals
#### MMU
Need boot eeprom mapped into memory.

- MMU_IN - write into memory, checks permissions unless task id is 0?
- MMU_CONTROL_IN - write into memory protection memory
- MMU_OUT - get data from memory / eeprom / whatever

#### MLU
Ops: AND, OR, NOT, XOR, POPCOUNT, MUL, DIV, MOD - lshift and rshift implemented as MUL and DIV.

- MLU out
- 3 bits for operation select
- Wired to A, B

### Control signals
5 + 5 + 4 + 3 = 17 bits hrmmm

#### Bus related
INs: A, B, M0, M1, M2, S0, S1, S2, PC0, PC1, PC2, MMU0, MMU1, MMU2, MMU, MMU_CONTROL, DISP, TASK, OPCODE, + peripherals - need 5 bit decoder

OUTs: A, B, M0, M1, M2, S0, S1, S2, K0, K1, K2, INTERRUPT, SUM, MMU, TASK, MLU + peripherals - need 5 bit decoder
INTERRUPT register needs to be read for ISR to know which devices to talk to.

#### Output
16 line decoder may be sufficient

- SUB
- PC increment
- OPCODE increment
- Reset uop counter (need to be careful with clocks here?)
- RESET - also wired to reset uop counter signal 
- SP increment
- SP decrement
- KSP increment
- KSP decrement
- Set carry flag from ALU
- Set interrupt enable
- Unset interrupt enable

Also MLU operation select:
- MLU - 3 bit operation select

#### Input
What if input bus via a register into EEPROM? Then can have potential variable length instructions if run out of opcodes, by making an opcode into an opcode page, and loading next byte into the control register.

If have stuff that can change on rising edge fed back into EEPROM, control signal output could change multiple times during HIGH clock? e.g. reset micro-up counter on CLK will change output of EEPROM. Reading in new data bus bits to control register may change EEPROM output. Need to latch EEPROM output on rising edge? Or just before?

If add latching to eeprom output, can do control logic stuff on rising edge as well, then can increase frequency? EEPROM would have all the time until the next rising edge to stabilise. Assume 100ns total, gives 10MHz

- 8 data bus bits into a register then fed into EEPROM
- 4 micro-op counter bits
- 7 opcode bits

### Instructions
0 - LOAD from bootloader? / Page fault?
LDA, LDB, LDC, LDD, OUT - immediate, memory addr, indirect memory addr
ADD, SUB, MUL, DIV, MOD - A, B
HLT, RST
JNZ, JZ, JMP
JLES, JLTS, JGES, JGTS
JLE, JLT, JGE, JGT
AND, OR, NOT, XOR - A, B
INT - software interrupt
PUSH, POP
RTI - return from interrupt - re-enables interrupts
bitwise ops (and, or, not, xor, nand?)

### Module notes:
#### MMU
Need to also interface into EEPROM for boot

#### Reset
Need to make sure everything is properly reset.

- TASK reg set to 0
- Boot EEPROM used

#### ALU
Produces carry and zero signal.

#### VGA

#### Clock
Pierce oscillator. Add frequency dividers using JK flipflops. 12 MHz with frequency dividers

### Peripherals

#### Keyboard
#### Mouse

#### USB mass storage?

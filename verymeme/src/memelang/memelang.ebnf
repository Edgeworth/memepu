grammar memelang;
file : (intf_defn | struct_defn | fn_defn | enum_defn | impl_defn)* EOF;

// Top level constructs:
intf_defn : 'intf' typename decl_block ;
struct_defn : 'struct' typename defn_block ;
fn_defn : fn_signature stmt_block ;
enum_defn : 'enum' typename enum_block ;
impl_defn : 'impl' typelist type defn_block ;

// Block related:
stmt_block : LBRACE stmt* RBRACE ;
defn_block : LBRACE ('static'? fn_defn | var_decl)* RBRACE ;
decl_block : LBRACE fn_decl* RBRACE ;
// TODO: Support structure like objects?
enum_block : LBRACE (IDENT '(' type '),')* RBRACE ;
// TODO: Ranges / OR / values?
match_block : LBRACE (IDENT ('()' | '(' IDENT (',' IDENT)* ')') stmt_block)* RBRACE ;

// Statement related:
stmt : expr ';' | var_defn | 'return' expr ';' | IDENT '=' expr ';' | stmt_for | stmt_if | stmt_match | ASM ;
stmt_for : 'for' var_defn expr ';' expr stmt_block ;
stmt_if : 'if' expr stmt_block ('else' stmt_if)* ('else' stmt_block)? ;
stmt_match : 'match' expr match_block ;

// Variable related:
var_decl : type IDENT ';' ;
var_defn : ('auto' | type) IDENT '=' expr ';' ;

// Expression related:
literal : STRING_LIT | CHAR_LIT | INTEGER_LIT | float_lit | bool_lit;
struct_lit : type LBRACE (IDENT ':' expr ',')* RBRACE ;
array_lit : '[]' | '[' expr (',' expr)* ']';
expr : expr '[' expr ']'  // Array subscript
    | fn_call  // Function call
    | expr '.' (fn_call | IDENT)  // Member access
    | expr '?'  // Result syntactic sugar
    | expr postfix_op  // Postfix operations
    | <assoc=right> prefix_op expr  // Prefix operations
    | expr binary_op expr  // Binary operations
    | <assoc=right> expr '?' expr ':' expr  // Ternary expression
    | <assoc=right> expr '=' expr  // Assignment
    | '(' expr ')' // Grouped expression
    | struct_lit
    | array_lit
    | type | literal ;

// Type related:
typebound : IDENT ; // TODO: Support complex type bounds?
typelist : '<' typebound (',' typebound)* '>' ;
typename : IDENT typelist? ;
// Identifiers either a concrete type or a set of types that should be deduced to a single type.
type : ('const'? '*' | '[' INTEGER_LIT ']')* 'const'?
    (IDENT ('<' type (',' type)* '>')? | builtin_type);

// Function related:
fn_decl : fn_signature ';' ; // Only allowed in interfaces.
fn_signature : 'fn' typename
    ('()' | '(' type IDENT (',' type IDENT)* ')') type ;
fn_call : type ('()' | '(' expr (',' expr)* ')') ;

// Ideas:
// Switch case (matching?)

// Terminals:
builtin_type : 'i8' | 'i16' | 'i32' | 'u8' | 'u16' | 'u32' | 'bool' ;
// Parse << and >> as two separate tokens to allow stuff like vector<vector<T>>.
binary_op : '*' | '/' | '%' | '+' | '-' | '>' '>' | '<' '<' | '<=' | '>=' | '<' | '>'
    | '==' | '!=' |  '&' | '^' | '|' | '&&' | '||';
prefix_op : '~' | '-' | '!' | '&' | '*' ;
postfix_op : '++' | '--' ;
INTEGER_LIT : [0-9]+ ;
float_lit : INTEGER_LIT '.' INTEGER_LIT ;
CHAR_LIT  : '\'' ~[\t\r\n] '\'' ;
STRING_LIT : ('"' ~[\t\r\n]* '"')+ ;  // Allow literal concat.
bool_lit : 'false' | 'true' ;
WHITESPACE : [ \t\r\n]+ -> skip ;
COMMENT : '//' ~[\n]* -> skip;
IDENT : [a-zA-Z_]+[a-zA-Z0-9_]* ;
LBRACE : '{' ;
RBRACE : '}' ;
ASM : 'asm' [ \t\r\n]* '{' ~[}]* '}' ;

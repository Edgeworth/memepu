// fn readf(data: *u8, size: i32) i32 {}

intf BinaryArith<A, B> {
  fn add(o: *A) T;  // TODO: Also variant in ret type?
}

impl<T> BinaryArith<*T, u32> for *T {
  fn add(o: *u32) *T {
    ret *this + *T(*o);  // TODO: Need to know wildcard types in parser.
  }
}

intf UnaryArith<T> {
  fn postinc() T;
}

impl<T> UnaryArith<*T> for *T {
  fn postinc() *T {
    tmp := *this;
    *this = *this + sizeof(**this);
    ret tmp;
  }
}

intf Indexable<I, T> {
  fn index(idx: *I) *T;
}

intf Comparable<T> {
  fn neq(o: *T) bool;
}

impl Comparable<i32> for u8 {
  fn neq(o: *i32) bool {
    printf("neq: %d %d != %d\n", *this, i32(*this), *o);
    ret i32(*this) != *o;
  }
}

fn strlen(s: *u8) u32 {
  len := 0u;
  while s[len++] != 0 {}
  ret len;
}

struct string {
  data: *u8;
  len: u32;

  static fn new(s: *u8) string {
    ret {data: s, len: strlen(s)};
  }
}

impl<T> Indexable<I, u8> for string {
  fn index(idx: *I) *u8 {
    ret &data[idx];
  }
}

fn print_cstr(s: *u8) {
  while *s != 0 {
    printf("%c", *(s++));
  }
}

fn main() i32 {
  SIZE := 128u;
  data : [SIZE]u8 = {};
  nbytes := readf(&data[0], SIZE);
  printf("got %d bytes: ", nbytes);
  print_cstr(&data[0]);
  printf("\n");
  printf("strlen result: %d\n", strlen(&data[0]));
  ret 0;
}

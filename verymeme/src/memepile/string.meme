fn strlen(s: *u8) u32 {
  len := 0u;
  while s[len++] != 0 {}
  ret len;
}

fn print_cstr(s: *u8) {
  while *s != 0 {
    printf("%c", *(s++));
  }
}

fn print_str(s: &const string) {
  for i := 0u; i < s.len; ++i {
    printf("%c", s[i]);
  }
}

struct string {
  data: *u8,
  len: u32,
}

impl string {
  static fn new(s: *u8) string {
    ret string.new(s, strlen(s));
  }
  static fn new(s: *u8, len: u32) string {
    data := malloc<u8>(len);
    memcpy(data, s, len);
    ret {data: data, len: len};
  }
  fn resize(len: u32) {
    free<u8>(self.data);
    self.data = malloc<u8>(len);
    self.len = len;
  }
}

impl<I> Indexable<I, u8> for const string {
  fn index(idx: &const I) &u8 {
    ret self.data[idx];
  }
}

impl BinaryArith<string, string> for const string {
  fn add(o: &const string) string {
    tmp := string{};
    tmp.resize(self.len + o.len);
    memcpy(tmp.data, self.data, self.len);
    memcpy(tmp.data + self.len, o.data, o.len);
    ret tmp;
  }
}

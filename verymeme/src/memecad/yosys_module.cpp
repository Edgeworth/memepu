#include "memecad/yosys_module.h"

#include <kernel/sigtools.h>

#include "memecad/parser.h"

namespace memecad {
USING_YOSYS_NAMESPACE

namespace {

constexpr const char* PASS_NAME = "memecad";

}  // namespace

std::vector<Schematic::SchematicFile>
convertVerilogToKicadSchematics(const std::string& memecad_map_filename,
    const std::vector<std::string>& verilog_filenames,
    const std::vector<std::string>& kicad_library_filenames) {
  // TODO: Support multiple libraries.
  verify_expr(kicad_library_filenames.size() == 1, "TODO: support multiple libraries");
  memecad::TestPass test_pass(memecad_map_filename, kicad_library_filenames.back());

  Yosys::yosys_setup();
  std::string yosys_cmd = "read -sv";
  for (const auto& filename : verilog_filenames)
    yosys_cmd += " " + filename;
  Yosys::run_pass(yosys_cmd);
  // Check all needed files exist. Also adjusts the port width so you can e.g. pass 32 bit
  // constant to a single bit port.
  Yosys::run_pass("hierarchy -check");
  Yosys::run_pass("check -assert");  // Check for misc problems.
  Yosys::run_pass(PASS_NAME);
  Yosys::yosys_shutdown();

  return test_pass.getMapper().getSchematic().writeHierarchy();
}

TestPass::TestPass(const std::string& memecad_map_filename,
    const std::string& kicad_library_filename) : Pass(PASS_NAME), mapper_(
    readFile(memecad_map_filename, false /* binary */),
    parseLibrary(kicad_library_filename)) {}

void TestPass::execute(std::vector<std::string> args, Design* design) {
  log_header(design, "Extracting modules...\n");
  extra_args(args, 1, design);

  for (auto& module_iter : design->modules_) {
    const auto&[module_id, module] = module_iter;
    if (!design->selected_module(module)) continue;

    // Generate kicad sheet for this module.
    if (!isLeafModule(module)) {
      SigMap sigmap(module);
      log("Checking module %s, bitcount: %d\n", log_id(module_id),
          static_cast<int>(sigmap.database.size()));

      for (auto& cell_iter : module->cells_) {
        const auto&[cell_id, cell] = cell_iter;
        log("  Checking cell %s, name: %s, type: %s\n", cell_id.c_str(),
            cell->name.c_str(), cell->type.c_str());
        for (auto& conn : cell->connections()) {
          const auto& conn_id = conn.first;
          const auto& sig = sigmap(conn.second);
          log("    Looking at connection: %s, signal: %s|%d\n",
              conn_id.c_str(), log_signal(sig), sig.size());
        }
      }

      log("  Looking at wires\n");
      for (auto& wire_iter : module->wires_) {
        const auto&[wire_id, wire] = wire_iter;
        log("    Looking at wire %s, start offset: %d, port id: %d\n", wire_id.c_str(),
            wire->start_offset, wire->port_id);
      }
      printf("\n");

      log("  Looking at module connections\n");
      for (auto& sigsig : module->connections()) {
        log("   Looking at sigsig: %s (size: %d) <=> %s (size: %d)\n", log_signal(sigsig.first),
            sigsig.first.size(), log_signal(sigsig.second), sigsig.second.size());
      }
      printf("\n");

      mapper_.addModule(*module);
      for (auto& cell_iter : module->cells_) {
        const auto&[cell_id, cell] = cell_iter;
        verify_expr(cell->type[0] == '\\', "unexpected non-user component");
        mapper_.addCell(*cell);
      }
    } else {
      printf("Skipping leaf module '%s'\n", log_id(module_id));
    }
  }
}

bool TestPass::isLeafModule(RTLIL::Module* module) {
  for (auto& cell_iter : module->cells_) {
    const auto&[cell_id, cell] = cell_iter;
    verify_expr(!cell_id.empty(), "expected cell name not empty");
    // If there is a non-autogenerated cell, i.e. submodule, this isn't a leaf module.
    if (cell_id[0] != '$') return false;
  }
  return true;
}

}  // memecad

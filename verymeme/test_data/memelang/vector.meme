
interface Iterator<T> {
  func next() T*;
}

interface Iterable<T> {
  func iter() Iterator<T>;
}

interface Movable<T> {
  func move_into(T* o) void;
}

interface Destructible<T> {
  func destroy() void;
}

struct vector_iter<T> {
  vector<T>* vec_;
  i16 idx_;

  func next() T* {
    if idx_ == vec_.size() {
      return nullptr;
    }
    idx_ = idx_ + 1;
    return vec_[idx_ - 1];
  }

  static func new(vector<T>* vec) vector_iter<T> {
    return vector_iter<T> {
      vec_: vec,
      idx_: 0,
    };
  }
}

struct vector<T> {
  T* data_;
  i16 size_;
  i16 cap_;

  func index(i16 index) T* {
    return data_[index];
  }

  func push(T val) void {
    if size_ == cap_ {
      cap_ = cap_ * 2;
      T* newdata = malloc(cap_ * sizeof(T));
      for (i16 i = 0; i < size_; i = i + 1) {
        newdata[i] = data_[i].move();
      }
      free(data_);
      data_ = newdata;
    }

    size_ = size_ + 1;
    data_[size_ - 1] = val;
  }

  func pop() T {
    size_ = size_ - 1;
    return data_[size_].move();
  }

  func size() i16 {
    return size_;
  }

  static func new() vector<T> {
    return vector<T>{
      data_: nullptr,
      size_: 0,
      cap_: 0,
    };  // RVO
  }
}

impl Iterable<T> for vector<T> {
  func iter() vector_iter<T> {
    return vector_iter<T>.new(this);
  }
}

impl Movable<T> for vector<T> {
  func move_into(vector<T>* o) void {
    o.data_ = data_;
    o.size_ = size_;
    o.cap_ = cap_;
    data_ = nullptr;
    size_ = 0;
    cap_ = 0;
  }
}

impl Destructible<T> for vector<T> {
  func destroy() void {
    for (i16 i = 0; i < size; i = i + 1) {
      data_[i].destroy();
    }
    free(data_);
  }
}

func swap<T>(T* a, T* b) void {
  T c = T{};
  a.move_into(&c);
  b.move_into(a);
  c.move_into(b);
}

func bubblesort<T>(vector<T>* v) void {
  for (i32 i = 0; i < v.size(); i++) {
    for (i32 j = 0; j < v.size() - 1; j++) {
      if v[j] > v[j + 1] {
        swap(v[j], v[j + 1]);
      }
    }
  }
}

func main() int8 {
    auto v = vector<int8>.new();
    v.push(4);
    v.push(3);
    v.push(1);
    bubblesort(v);
    return 1;
}

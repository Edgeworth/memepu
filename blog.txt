#### TODO / Parts to get
- 1 M potentiometer - check footprint when get
- DPST switch - make footprint
- micro usb connection - check footprint
- if can route with current spacing, make everything closer to gether and try again
- increase track width ?
- More LEDs - but option to turn them all off.
- bypass cap for each ic
- mounting holes
- timer interrupt
- peripheral interconnect bus connector
- LU ops - AND etc
- RESET button
- add bulk decoupling on power supply

#### 2nd Board - ideas
- VGA
- AUDIO
- USB - keyboard, mouse

stack pointers
status/control reg
interrupt reg
program counter
display module
memory module
opcode register
MLU
control logic
vga
audio

#### ALU
Use 4-bit binary counters for add. For subtract, using 2's complement, so:
-b = ~b + 1
a - b = a + ~b + 1
Can create ~b by XORing with SUB flag. Can do +1 by putting SUB flag into carry.

Needs to access A and B registers all the time, so A and B registers need transceivers.

#### Stack pointer:
24 bit, needs set, increment, decrement. - use 74hc193

####Protection (currently thinking)
Task register
Kernel
4KB pages
Upon access memory, checks - if check fails, what do? I guess have to abort immediately, could do by resetting the micro-op counter and the opcode ? Alternately, have a page fault control signal.

Lookup: task id register (8 bit) + 9 bit page id => 8 bits (so 3 bits of addr) 

Privileged instructions?

#### Control logic
What if input bus via a register into EEPROM? Then can have potential variable length instructions if run out of opcodes, by making an opcode into an opcode page, and loading next byte into the control register. Can also load Status/Control register into this reg, and do conditional jumps etc.

If have stuff that can change on rising edge fed back into EEPROM, control signal output could change multiple times during HIGH clock? e.g. reset micro-up counter on CLK will change output of EEPROM. Reading in new data bus bits to control register may change EEPROM output. Need to latch control logic output.

If add latching to eeprom output, can do control logic stuff on rising edge as well, then can increase frequency? EEPROM would have all the time until the next rising edge to stabilise. Assume 100ns total, gives 10MHz. HOWEVER, need time to output registers onto bus etc, so need to do on falling edge? Options:
1. Slower clock, latch control on falling edge, AND IN signals on rising edge.
2. Broken: Latch control on rising edge - need to AND IN signals (if IN signal continuously high need to AND to make sure it pulses), so IN signals need to be asserted earlier + HOLD time etc. Same issue for PRE edge and POST edge action idea
3. Best soln: Latch on falling edge. AND IN's on rising. May require hold constraints for slower stuff like memory. Can do IN and OUT on same cycle for fast things.


#### Boot sequence
Have EEPROM mapped into some high bits in memory (e.g. bit 23 of address space goes to eeprom). Need to make sure PC is set to something initially good...

#### Peripheral interface design
How to talk with peripherals? Need some kind of polling along bus - e.g. control signals for each peripheral - in, out. On in, peripheral reads data from bus. On out, peripheral may assert bus.

#### Random thoughts
Trying to decide on LED brightness - use 10k or 1k resistors. If use 1k, then drawing 5mA from ICs, which could be a lot, e.g. clock source can only source 25mA. Went with 5mA for now.

#### Clock source notes
Pierce oscillator: needs a filter for frequency ( high q value means graph of attenuation is not spread out?) and an amplifier. any noise will start the circuit. can make amplifier by biasing (connect output to input with a 1M resistor) an inverter. inverter provides 180 degree rotation. use capacitors to provide extra 180 degree rotation, so it can constructively interfere.

Considering up to 8 clock sources... would be good for experimentation. Or variable frequency multiplier if that exists?

frequency divider using binary counter or jk flipflops

switching between clock sources can cause glitches. fundamentally this is an issue of the asynchronous input, that isn't synced with the clock. if the clock is low, then the source is switched, the new clock could be high, which would give a short cycle, breaking hold time, setup time constraints. also, during clock setup, maybe the clock takes a while to get running properly. so, xor all clock select inputs. if any of them change, the output of the final xor gate will change. latch this on the falling edge into a flip flop. connect output (A) of flipflop into a xor gate, and rc circuit into a schmitt triggered inverter. if the clock select changes, then until  the RC circuit charges, the output of the inverter will be the same as A. xoring those two will give a low signal while rc is charging, i.e. for a delay after the clock source has changed, then will go high. can AND this with the clock to disable the clock for a timeout on changes. during reset, if we feed the reset signal into the clock select xor gates, we will also disable the clock for a bit on reset, while the state in the computer is reset.

Bit 0 of the bus is LSB.

#### Interrupt design decisions
Edge triggered - needs D flip-flop for each IRQ line. :

- Need some way to clock it on the peripheral's demand, otherwise potentially complicated to make peripheral assert the data line long enough. Can miss interrupts if the peripheral asserts the IRQ during the interrupt handler (even though interrupts are disabled, we still need to record them), then the interrupt handler marks the interrupt as handled. Even if the interrupt handler marks the interrupt bit as what the device is currently asserting, timing issues can still happen i.e.: peripheral asserts, ISR started, peripheral asserts again, ISR marks interrupt bit as what the peripheral is currently asserting the line as, which has already gone back to 0, so the second interrupt is missed. Need a counter system to fix this.

Level triggered with ACKs:

- Each device will assert its interrupt line until it gets an ACK from the CPU via IN/OUT lines to peripherals. The cpu will potentially then read out data (e.g. from keyboard). If there is data remaining, the peripheral can keep its interrupt line asserted. In the case of timer like interrupts, the timer device could keep a count of ack'd timer interrupts and assert the IRQ while the count is positive, or it could just not care, and two timer interrupts very close together could be missed.
- This also allows some sharing of interrupt lines, then the CPU can poll each device on the same line.

Go with level triggered.

#### Maximum safe frequency:
EEPROM delay: 70ns
SRAM delay: 70ns

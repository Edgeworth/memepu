#### TODO / Parts to get
- 1 M potentiometer - check footprint when get
- DPST switch - make footprint
- micro usb connection - check footprint
- increase track width ?
- More LEDs - but option to turn them all off.
 - leds for control logic?
- bypass cap for each ic
- mounting holes
- timer interrupt
- peripheral interconnect bus connector
- LU ops - AND etc
- RESET button
- Check footprints for bulk decoupling caps
- Compress space
- Replace freq divider with two 4-bit binary counters.
- Go through BOM and order extras

#### 2nd Board - ideas
- VGA
- AUDIO
- USB - keyboard, mouse

#### Tests to run:
- Stack pointer up/down counting.

stack pointers
status/control reg
interrupt reg
program counter
display module
memory module
opcode register
MLU
control logic
vga
audio

#### ALU
Use 4-bit binary counters for add. For subtract, using 2's complement, so:
-b = ~b + 1
a - b = a + ~b + 1
Can create ~b by XORing with SUB flag. Can do +1 by putting SUB flag into carry.

Needs to access A and B registers all the time, so A and B registers need transceivers.

#### Stack pointer:
24 bit, needs set, increment, decrement.

Switched from 74hc193 to 74hc191 since 74hc193 requires ripple carry/borrow which is slow. 125 ns latency for 6 chips (5 ripples). 74hc191 can be set up to use some flag. But, need to AND all previous flags together. It doesn't have the nice property the 74161 has where the carry output is only high if the previous carry output is also high.

#### MMU
3 MMU internal registers for memory. Support mapping an EEPROM in for boot or something.

Protection (currently thinking)
Task register
Kernel
2 MB address space, 1024 byte pages, read write for each one.
Upon access memory, checks - if check fails, what do? I guess have to abort immediately, could do by resetting the micro-op counter and the opcode ? Alternately, have a page fault control signal.

If reset micro-op counter and opcode, then:
1. no opportunity for potential cleanup of instruction
2. Questions about what initial state should do.
3. Have multiple things asserting control signals. The control logic is latched. Potentially gets complicated to have multiple controllers.

Page fault control flag:
Can be on any time the MMU has an address the task can't access loaded.

Decision: Use page fault control flag.

Lookup: task id register (8 bit) + 9 bit page id => 8 bits, rw for each one (so 2 bits of addr) 

What happens on interrupt / page fault? Need to set task register to 0 to read kernel memory, but need to know the previous task. Save currently running task in ram? If so, how transfer control back to task. Need specific instruction to set task register then jump? Decision: Store in memory. Then, use specific instruction to set task register and jump at the same time.

#### Control logic
What if input bus via a register into EEPROM? Then can have potential variable length instructions if run out of opcodes, by making an opcode into an opcode page, and loading next byte into the control register. Can also load Status/Control register into this reg, and do conditional jumps etc. Decision: 4 bit binary counter reading from bus fed into EEPROM (lack of eeprom inputs).

If have stuff that can change on rising edge fed back into EEPROM, control signal output could change multiple times during HIGH clock? e.g. reset micro-up counter on CLK will change output of EEPROM. Reading in new data bus bits to control register may change EEPROM output. Need to latch control logic output.

If add latching to eeprom output, can do control logic stuff on rising edge as well, then can increase frequency? EEPROM would have all the time until the next rising edge to stabilise. Assume 100ns total, gives 10MHz. HOWEVER, need time to output registers onto bus etc, so need to do on falling edge? Options:
1. Slower clock, latch control on falling edge, AND IN signals on rising edge.
2. Broken: Latch control on rising edge - need to AND IN signals (if IN signal continuously high need to AND to make sure it pulses), so IN signals need to be asserted earlier + HOLD time etc. Same issue for PRE edge and POST edge action idea
3. Best soln: Latch on falling edge. AND IN's on rising. May require hold constraints for slower stuff like memory. Can do IN and OUT on same cycle for fast things.

Make control logic like a finite state machine. Opcodes:
0: Boot sequence
1: Fetch opcode
2: Page fault

Reset:
Needs to reset when turn on

Control planes:
IN plane ANDed with the clock.
OUT plane not anded.
CONTROL plane varies.

#### Boot sequence
Have EEPROM mapped into some high bits in memory (e.g. bit 23 of address space goes to eeprom). Need to make sure PC is set to something initially good - use boot sequence opcode 0.

#### Peripheral interface design
How to talk with peripherals? Need some kind of polling along bus - e.g. control signals for each peripheral - in, out. On in, peripheral reads data from bus. On out, peripheral may assert bus.

#### Random thoughts
Trying to decide on LED brightness - use 10k or 1k resistors. If use 1k, then drawing 5mA from ICs, which could be a lot, e.g. clock source can only source 25mA. Went with 5mA for now.

Instead of using falling edge, delay clock slightly for control logic latch? Gives more time (enough time for memory to react in one cycle). Decision: Can't do this, since we need time to write into memory on rising edge. (see maximum safe frequency calculation)

#### Clock source notes
Pierce oscillator: needs a filter for frequency ( high q value means graph of attenuation is not spread out?) and an amplifier. any noise will start the circuit. can make amplifier by biasing (connect output to input with a 1M resistor) an inverter. inverter provides 180 degree rotation. use capacitors to provide extra 180 degree rotation, so it can constructively interfere.

Considering up to 8 clock sources... would be good for experimentation. Or variable frequency multiplier if that exists?

frequency divider using binary counter or jk flipflops

switching between clock sources can cause glitches. fundamentally this is an issue of the asynchronous input, that isn't synced with the clock. if the clock is low, then the source is switched, the new clock could be high, which would give a short cycle, breaking hold time, setup time constraints. also, during clock setup, maybe the clock takes a while to get running properly. so, xor all clock select inputs. if any of them change, the output of the final xor gate will change. latch this on the falling edge into a flip flop. connect output (A) of flipflop into a xor gate, and rc circuit into a schmitt triggered inverter. if the clock select changes, then until  the RC circuit charges, the output of the inverter will be the same as A. xoring those two will give a low signal while rc is charging, i.e. for a delay after the clock source has changed, then will go high. can AND this with the clock to disable the clock for a timeout on changes. during reset, if we feed the reset signal into the clock select xor gates, we will also disable the clock for a bit on reset, while the state in the computer is reset.

Bit 0 of the bus is LSB.

#### Interrupt design decisions
Edge triggered - needs D flip-flop for each IRQ line. :
- Need some way to clock it on the peripheral's demand, otherwise potentially complicated to make peripheral assert the data line long enough. Can miss interrupts if the peripheral asserts the IRQ during the interrupt handler (even though interrupts are disabled, we still need to record them), then the interrupt handler marks the interrupt as handled. Even if the interrupt handler marks the interrupt bit as what the device is currently asserting, timing issues can still happen i.e.: peripheral asserts, ISR started, peripheral asserts again, ISR marks interrupt bit as what the peripheral is currently asserting the line as, which has already gone back to 0, so the second interrupt is missed. Need a counter system to fix this.

Level triggered with ACKs:
- Each device will assert its interrupt line until it gets an ACK from the CPU via IN/OUT lines to peripherals. The cpu will potentially then read out data (e.g. from keyboard). If there is data remaining, the peripheral can keep its interrupt line asserted. In the case of timer like interrupts, the timer device could keep a count of ack'd timer interrupts and assert the IRQ while the count is positive, or it could just not care, and two timer interrupts very close together could be missed.
- This also allows some sharing of interrupt lines, then the CPU can poll each device on the same line.

Decision: Go with level triggered.

#### Maximum safe frequency:
EEPROM delay: 70ns
SRAM delay: 70ns
SRAM write pulse min width: 50ns, so CLK needs to be 50ns HIGH => 100ns period.

100ns => 10 MHz